---
title: 前端项目拆库
categories: Git
tags:
    - Git
---

# 前端代码拆库

## 背景

### Monorepo 和 Multirepo

**Monorepo**

`Monorepo` 是管理项目代码的一个方式，指在一个项目仓库 (`repo`) 中管理多个模块/包 (`package`)，不同于常见的每个模块建一个 `repo`。而 `lerna` 是 `Monorepo` 目前最好的一种解决方案，通过 `lerna` 的一些命令，例如 `lerna run xxx` 可以统一对各个模块进行操作。

**Multirepo**

`Multirepo` 从字面意思上来说就是多个 `repo` ，每个模块或者项目创建各自的仓库，单独开发维护，相互之间调用只能以npm包的形式或者使用 `git` 子模块。

----------

我们的项目之前是基于 `monorepo` 形式创建的，即多个子工程在一个项目中管理，然后使用 `lerna` 管理工具，统一对 packages 文件夹下面的子模块进行管理。

由于项目前后端分离、前端工程和后端工程版本要保持对应一致、要部署到多个不同的环境、同时我们又要引入其他部门的基础服务代码，这一系列的要求就导致项目使用monorepo的模式进行不下去。

举个例子

1. 开发环境和测试环境配置不相同。
2. 测试环境中的基础服务包版本和开发环境中版本不一致，即在 develop 环境，使用的某个基础服务包版本为 1.1.9， test 环境使用的版本是1.0.9，因为两个环境的后端版本不相同，前端也要保持统一。
3. 开发在各自模块下进行开发，每个团队要在自己组所属模块下面开发，不方便区分哪些代码进行开发，哪些代码进行提测。

基于以上情况，这边对代码进行拆分。

## 仓库、分支介绍

将代码拆分成以下几种 `git` 仓库

- **front-code**: 前端纯净仓库，不包含任何业务代码，所有新模块都基于此代码进行初始化。
- **front-[模块缩写]**: 各个子模块的工程，只包含每个模块的功能代码。
- **front-boot**: 前端基础模块仓库，项目所需要的一些公共组件，方法，基础引用都在此模块中，每个子模块都要引入的模块。
- **front-core**: 前端框架仓库，前端测试环境，开发环境，发布环境都基于此仓库进行部署。

原本项目中没有`boot`这个模块，综合考虑下来，应该建立一个公共模块，让所有的子模块都依赖，并且将公共内容放到这个模块中，之后对于公共内容的新增、修改都只需要改动这一个模块，然后发布 `npm包` ，小版本直接升级依赖即可, boot 这个模块要引入到各个模块的 `devDependencies` 中，可以防止重复打包.

顺便拆了个纯净仓库，项目以后的开发会有其他项目，可以直接基于这个项目工程拿取代码进行开发，基本的配置都配置完成。‘

`front-core` 这个仓库 分成 `master` `test` `develop` 这几个分支，其中 `master` 分支为正式环境发布分支，没有任何业务代码，全部引入的是文档打版的 `npm包`。 `test` 分支为测试环境的发布分支，使用 `git子模块` 将各个子模块的 `test` 分支代码进行引入。 `develop` 分支为开发环境的发布分支，同样使用 `git子模块` 将各个子模块的 `develop` 分支代码进行引入。

`front-[模块缩写]`这种命名的仓库就分配到各个组，由各个组创建 develop 和 test 分支进行开发，完全解决组之间代码冲突的问题。

## 优缺点

### 优点

1. 各组负责自己模块，避免组间冲突，同时减轻前端管理组的压力。
2. 可针对各种前端发布条件进行修改，各组、依赖模块、基础模块等都完全区分开，不相互影响。
3. 前端启动项目所消耗时间减少，提升开发效率。
4. 公共模块提取了代码，减少冗余代码，项目更清晰简洁。

### 缺点

1. 各组人员的 `git` 水准参差不齐， 对各组负责人来说压力增大。
2. 组件模块相互依赖，需要实时沟通，一旦版本不统一，最终会出现多版本打包。

## 知识点

- Monorepo
- Multirepo
- Git Submodule
- Git Flow
- devDependencies 和 dependencies 的区别

## 总结

整个拆库从构思到测试、建库、正式发布、讲解持续了近2周。只要思路通了，整个模式都玩的通，剩下的就是完善模块，让模块更纯粹和简洁。

后续还准备将 front-code 做成脚手架，使用脚手架创建项目，将一些简单的命令集成进来，使得管理方便。