---
title: 前端版本控制
categories: 版本控制
tags:
    - 版本控制
---


# 前端版本控制

## 背景

公司代码采用 `monorepo` 模式，在 `package` 文件夹下管理各个模块，整个项目采用 `lerna` 进行管理。

最近项目也到稳定期，需要进行发版和发布，对于项目来说，直接使用某一个版本的`npm`包即可，于是要制定一个版本控制的规范。

公司的发布源设置为私有源，但是想了想这个方式同样适用于 `npm` 公有源。

## 前言

> 使用语义化版本控制(`Semantic Versioning`)，你必须先有定义好的公共 API 。这可以透过文件定义或代码强制要求来实现(API 文档)。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z （主版本号.次版本号.修订号），先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

## 版本号递增规则

- 主版本号：当你做了不兼容的 API 修改，递增主版本号
- 次版本号：当你做了向下兼容的功能性新，递增次版本号
- 修订号：当你做了向下兼容的问题修正，递增修订号
  

## 语义化版本控制规范

- 使用语义化版本控制的软件`必须`定义公共 API。该 API 可以在代码中被定义或出现于严谨的文件内。无论何种形式都应该力求精确且完整。
- 标准的版本号`必须`采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且`禁止`在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素`必须`以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
- 标记版本号的软件发行后，`禁止`改变该版本软件的内容。任何修改都`必须`以新版本发行。
- 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。**以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号**
- 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。**当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。**
- 修订号 Z（x.y.Z | x > 0）`必须`在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
- 次版本号 Y（x.Y.z | x > 0）`必须`在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也`必须`递增。也`可以`在内部程序有大量新功能或改进被加入时递增，其中`可以`包括修订级别的改变。每当次版本号递增时，修订号`必须`归零。
- 主版本号 X（X.y.z | X > 0）`必须`在有任何不兼容的修改被加入公共 API 时递增。其中`可以`包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号`必须`归零。
- 先行版本号`可以`被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符号来修饰。标识符号`必须`由 ASCII 码的英数字和连接号 [0-9A-Za-z-] 组成，且`禁止`留白。数字型的标识符号`禁止`在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法达到兼容的需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。
- 版本编译信息`可以`被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符号来修饰。标识符号`必须`由 ASCII 的英数字和连接号 [0-9A-Za-z-] 组成，且`禁止`留白。当判断版本的优先层级时，版本编译信息可被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。
- 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，`必须`把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。由左到右依序比较每个标识符号，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较，例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。例如：1.0.0-alpha < 1.0.0。有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级`必须`透过由左到右的每个被句点分隔的标识符号来比较，直到找到一个差异值后决定：只有数字的标识符号以数值高低比较，有字母或连接号时则逐字以 ASCII 的排序来比较。数字的标识符号比非数字的标识符号优先层级低。若开头的标识符号都相同时，栏位比较多的先行版本号优先层级比较高。范例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0- rc.1 < 1.0.0。

## 版本号信息

- **alpha**：内部测试版。α是希腊字母的第一个，表示最早的版本，一般用户不要下载这个版本，这个版本包含很多BUG，功能也不全，主要是给开发人员和测试人员测试和找BUG用的。
- **beta**：公开测试版。β是希腊字母的第二个，顾名思义，这个版本比alpha版发布得晚一些，主要是给“部落”用户和忠实用户测试用的，该版本任然存在很多BUG，但是相对alpha版要稳定一些。这个阶段版本的软件还会不断增加新功能。如果你是发烧友，可以下载这个版本。
- **RC**(Release Candidate)：候选版本。该版本又较beta版更进一步了，该版本功能不再增加，和最终发布版功能一样。这个版本有点像最终发行版之前的一个类似预览版，这个的发布就标明离最终发行版不远了。作为普通用户，如果你很急着用这个软件的话，也可以下载这个版本。
- **stable**：稳定版。在开源软件中，都有stable版，这个就是开源软件的最终发行版，用户可以放心大胆的用了。
- **RELEASE**：最终版本。在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号®。

## 发版流程

1. 当开发达到发版要求、对某个版本进行了bug修复，或者新增相关内容之后，需要进行发版。
2. 所有模块版本从 `1.0.0` 开始，基本的修改和bug修复后版本最后一位加1，即 `1.1.0` > `1.1.1`。
3. 当需要大版本发布时候，各组需要对中间版本进行升级，最后版本从0开始，即 `1.1.X` > `1.2.0`。
4. **禁止**在同一版本多次发布内容，每次发版版本号加1，请勿随意增减版本号。

## 发布操作

#### 源

将本项目发布到`nexus npm`私有源仓库

#### 进入到发布模块

```bash
$ cd packages/< xxxx module>
$ yarn transpile
```

#### 修改版本号

修改模块文件下`package.json`中 `version`字段的值，手动+1

```json
"version": "1.1.0",
// 手动加1
"version": "1.1.1",
```

#### 生成 `auth hash`**

```bash
echo -n 'username:password' | openssl base64
# 得到 40位编码
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
```

`username` 和`password`需要找项目负责人进行提供。

#### 配置npm config

执行如下命令将上面的配置加入到`node.js`全局环境变量配置文件`.npmrc`中

```bash
$ npm config edit 
```

```conf
email=your email
always-auth=true
_auth=yourbase64hashcode
```

#### 发布

```bash
$ npm publish
```

#### 查看

1. 打开提供的源地址地址

2. 找到自己刚刚发布的包

3. 点击发布模块进入，看到最新版本已经改变，即为发布成功。